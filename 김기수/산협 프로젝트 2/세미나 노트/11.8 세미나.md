#### Fast (Trapless) Kernel Probes Everywhere
Kprobe로 인한 성능적인 오버헤드를 줄이기 위해 제안 됨.
컴파일러쪽을 접근하였음.
custom handler function -> kprobe에 넣어주고, 얘를 통해 해당 함수를 실행시키게 됨.
성능적으로 영향을 주기 때문에, 손해를 감수하고 사용하게 됨.
이 논문에서는 Kernel Control Flow Integrity를 중점적으로 봄 -> 보안적인 이슈

기본적인 Kprobe 진행
trap을 통해서 Breakpoint trap을 통해 해당 함수로 이동하게 됨.
pre handler와 post handler가 있음. 총 인터럽트가 2번 발생하게 됨. 이는 context switch를 일으키므로 상당한 오버헤드가 발생하게 됨.
이 때 최소 6000 사이클을 사용하게 됨.


trapless kernel prob를 만들게 됨.
인터럽드 대신에 call이나 jump를 사용하게 함.
int3는 인터럽트를 일으키기 위해 1바이트만 있으면 된다. -> call이나 jump는 새로운 instruction이 필요하다
이때 5바이트 정도를 일부러 모든 커널 instruction 앞에 비워두고,(NOP으로) 여기다가 해당 코드를 넣음

트램폴린이라는 공간을 따로 두어서 루틴을 작동시키고자 함.
그냥 추가적인 작업을 위한 저장공간이다.
indirect jump vector라고 볼 수 있다.
user code에서 kernel code를 직접 실행한느 것이 아닌 trampoline의 영역에서 jump를 통해 실행하게 함.
NOP을 추가하지 않고 해당 instruction을 jump로 바꾸고, 그 안에서 해당 instruction을 실행시키게 됨.

주소를 상대적인 주소를 사용하게 됨으로써, overwriting 문제가 발생하게 됨.
basic block이라는 단위로 쪼개서 관리하고자 함.